@using SparksInTheSoftware.Sudoku;

<div class="sudoku-board">
    <div class="sudoku-top-line">
        <select @bind="puzzleDifficulty">
            <option value="Simple">Simple</option>
            <option value="Easy">Easy</option>
            <option value="Intermediate">Intermediate</option>
            <option value="Expert">Expert</option>
        </select>
        <input type="text" @bind="puzzleNumber" placeholder="1-100"/>
        <button @onclick="OnClickLoadPuzzle">Load</button>
        <button @onclick="OnClickClearPuzzle">Clear</button>
        <button @onclick="OnClickSolvePuzzle">Solve</button>
    </div>
    <CascadingValue Value="this">
        @for (int row = 0; row < Puzzle.Rows; row++)
            {
            if ((row % Puzzle.BlockSize) == 0)
                {
                <div class="sudoku-row-gap"/>
                }
            <div class="sudoku-row">
                @for (int column = 0; column < Puzzle.Columns; column++)
                    {
                    if ((column % Puzzle.BlockSize) == 0)
                        {
                        <div class="sudoku-column-gap"/>
                        }
                    <SudokuCell Cell="@(Puzzle.Cells[row, column])" />
                    }
            </div>
            }
    </CascadingValue>
    <div class="sudoku-bottom-line">
        <div data-toggle="tooltip" data-placement="top" title="Load Next Puzzle">
            <img src="svg/chevron-right.svg"  @onclick="OnClickLoadNextPuzzle"/>
        </div>
        <div data-toggle="tooltip" data-placement="top" title="Load Previous Puzzle">
            <img src="svg/chevron-left.svg"  @onclick="OnClickLoadPrevPuzzle"/>
        </div>
        <ToggleButton @bind-State="EditModeState" StateStrings="@editModeStateStrings" StateClasses="@editModeStateClasses"/>
        <ToggleButton @bind-State="HexModeState" StateStrings="@hexModeStateStrings" StateClasses="@hexModeStateClasses"/>
        <div class="status-line">@statusMessage</div>
    </div>
</div>

<style>
    .hex-mode-3x3
        {
        background-color: lightgoldenrodyellow;
        color: black;
        }

    .hex-mode-3x3:hover
        {
        background-color: yellow;
        }

    .hex-mode-4x4
        {
        background-color: lavender;
        color: black;
        }

    .hex-mode-4x4:hover
        {
        background-color: lavenderblush;
        }

    .edit-mode-off
        {
        background-color: white;
        color: black;
        }

    .edit-mode-off:hover
        {
        color: blue;
        }

    .edit-mode-on
        {
        background-color: cornflowerblue;
        color: white;
        }

    .edit-mode-on:hover
        {
        color: yellow;
        }
</style>

@code
    {
        [Parameter] public Puzzle Puzzle { get; set; }
    private int puzzleNumber = 1;
    private string puzzleDifficulty = "Intermediate";
    private string statusMessage = "";

    private string[] hexModeStateStrings = { "3 x 3", "4 x 4" };
    private string[] hexModeStateClasses = { "hex-mode-3x3", "hex-mode-4x4" };
    private bool hexMode = false;
    public int HexModeState
        {
        get
            {
            return this.hexMode ? 1 : 0;
            }
        set
            {
            this.hexMode = (value == 1);
            if (this.hexMode)
                {
                Puzzle = new Puzzle(4);
                }
            else
                {
                OnClickLoadPuzzle(); // For now LoadPuzzle() only loads 3x3 block size
                }
            StateHasChanged();
            }
        }

    private string[] editModeStateStrings = { "Edit: Off", "Edit: On" };
    private string[] editModeStateClasses = { "edit-mode-off", "edit-mode-on" };
    public bool EditMode { get; set; } = false;
    private int EditModeState
        {
        get
            {
            return this.EditMode ? 1 : 0;
            }
        set
            {
            this.EditMode = (value == 1);
            StateHasChanged();
            }
        }

    private void OnClickClearPuzzle()
        {
        Puzzle.Clear();
        }

    private void OnClickLoadPuzzle()
        {
        LoadPuzzle(this.puzzleNumber, this.puzzleDifficulty);
        }

    private void LoadPuzzle(int newPuzzleNumber, string newPuzzleDifficulty)
        {
        Puzzle newPuzzle = Puzzle.LoadPuzzle(newPuzzleNumber - 1, newPuzzleDifficulty);
        if (newPuzzle != null)
            {
            this.hexMode = false;  // Load puzzle only loads 3x3 puzzles for now.
            this.Puzzle = newPuzzle;
            this.puzzleNumber = newPuzzleNumber;
            this.puzzleDifficulty = newPuzzleDifficulty;
            this.statusMessage = "";
            StateHasChanged();
            }
        }

    private void OnClickLoadNextPuzzle()
        {
        LoadPuzzle(this.puzzleNumber + 1, this.puzzleDifficulty);
        }

    private void OnClickLoadPrevPuzzle()
        {
        LoadPuzzle(this.puzzleNumber - 1, this.puzzleDifficulty);
        }

    private void ReportSolutionProgress(object sender, Puzzle.SolutionProgressReport progessReport)
        {
        //Puzzle.SetValue(progessReport.Row, progessReport.Column, progessReport.Value);
        //StateHasChanged();
        }

    private async Task OnClickSolvePuzzle()
        {
        Progress<Puzzle.SolutionProgressReport> progress = new Progress<Puzzle.SolutionProgressReport>();
        progress.ProgressChanged += ReportSolutionProgress;
        this.statusMessage = "Solving...";
        int solutions = await Puzzle.Solve(10, progress, true);

        if (solutions > 0)
            {
            this.statusMessage = $"Found {solutions} solutions.";
            Puzzle solution = Puzzle.Solutions[0];
            for (int row=0; row < Puzzle.Rows; row++)
                {
                for (int column = 0; column < Puzzle.Columns; column++)
                    {
                    Puzzle.Cells[row, column].Value = solution.Cells[row, column].Value;
                    }
                }
            StateHasChanged();
            }
        else
            {
            this.statusMessage = "No soltuions.";
            }
        }

    private void SetFocus(int row, int column)
        {
        SudokuCell sudokuCell = Puzzle.Cells[row, column].View as SudokuCell;

        if (sudokuCell != null)
            {
            sudokuCell.Focus();
            }
        }

    private const bool skipReadOnly = false;

    public void NavigateUp(SudokuCell sudokuCell)
        {
        Puzzle.Cell fromCell = sudokuCell.Cell;
        int row = fromCell.Row;
        int column = fromCell.Column;

        int rowsChecked = 0;
        do
            {
            rowsChecked++;
            if (rowsChecked > Puzzle.Rows)
                return;

            row--;
            // wrap to bottom
            if (row < 0)
                {
                row = Puzzle.Rows - 1;
                }

            } while (skipReadOnly && Puzzle.Cells[row, column].ReadOnly);

        SetFocus(row, column);
        }

    public void NavigateDown(SudokuCell sudokuCell)
        {
        Puzzle.Cell fromCell = sudokuCell.Cell;
        int row = fromCell.Row;
        int column = fromCell.Column;

        int rowsChecked = 0;
        do
            {
            rowsChecked++;
            if (rowsChecked > Puzzle.Rows)
                return;

            row++;
            // wrap to top
            if (row >= Puzzle.Rows)
                {
                row = 0;
                }

            } while (skipReadOnly && Puzzle.Cells[row, column].ReadOnly);

        SetFocus(row, column);
        }

    public void NavigateLeft(SudokuCell sudokuCell)
        {
        Puzzle.Cell fromCell = sudokuCell.Cell;
        int row = fromCell.Row;
        int column = fromCell.Column;

        int columnsChecked = 0;
        do
            {
            columnsChecked++;
            if (columnsChecked > Puzzle.Columns)
                return;

            column--;
            // wrap to right
            if (column < 0)
                {
                column = Puzzle.Columns - 1;
                }

            } while (skipReadOnly && Puzzle.Cells[row, column].ReadOnly);

        SetFocus(row, column);
        }

    public void NavigateRight(SudokuCell sudokuCell)
        {
        Puzzle.Cell fromCell = sudokuCell.Cell;
        int row = fromCell.Row;
        int column = fromCell.Column;

        int columnsChecked = 0;
        do
            {
            columnsChecked++;
            if (columnsChecked > Puzzle.Columns)
                return;

            column++;
            // wrap to left
            if (column >= Puzzle.Columns)
                {
                column = 0;
                }

            } while (skipReadOnly && Puzzle.Cells[row, column].ReadOnly);

        SetFocus(row, column);
        }
    }
