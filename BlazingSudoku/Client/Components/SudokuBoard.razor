@using Sudoku;
@using BlazingSudoku.Client.Components;

<div class="sudoku-board">
    <div class="sudoku-top-line">
        <select @bind="puzzleDifficulty">
            <option value="Simple">Simple</option>
            <option value="Easy">Easy</option>
            <option value="Intermediate">Intermediate</option>
            <option value="Expert">Expert</option>
        </select>
        <input type="text" @bind="puzzleNumber" placeholder="1-100"/>
        <button @onclick="OnClickLoadPuzzle">Load</button>
        <button @onclick="OnClickClearPuzzle">Clear</button>
        <button @onclick="OnClickSolvePuzzle">Solve</button>
    </div>
    <CascadingValue Value="this">
        @for (int row = 0; row < Puzzle.Rows; row++)
            {
            if ((row % Puzzle.BlockSize) == 0)
                {
                <div class="sudoku-row-gap"/>
                }
            <div class="sudoku-row">
                @for (int column = 0; column < Puzzle.Columns; column++)
                    {
                    if ((column % Puzzle.BlockSize) == 0)
                        {
                        <div class="sudoku-column-gap"/>
                        }
                    <SudokuCell Cell="@(Puzzle.Cells[row, column])" />
                    }
            </div>
            }
    </CascadingValue>
    <div class="sudoku-bottom-line">
        <div data-toggle="tooltip" data-placement="top" title="Load Next Puzzle">
            <img src="svg/chevron-right.svg"  @onclick="OnClickLoadNextPuzzle"/>
        </div>
        <div data-toggle="tooltip" data-placement="top" title="Load Previous Puzzle">
            <img src="svg/chevron-left.svg"  @onclick="OnClickLoadPrevPuzzle"/>
        </div>
        <label for="editPuzzle">Edit Puzzle</label>
        <input type="checkbox" id="editPuzzle" @bind="EditMode" />
        <label for="hexPuzzle">Hex</label>
        <input type="checkbox" id="hexPuzzle" @bind="HexMode"/>
        <div class="status-line">@statusMessage</div>
    </div>
</div>

@code
    {
    [Parameter] public Puzzle Puzzle { get; set; }
    private int puzzleNumber = 1;
    private string puzzleDifficulty = "Intermediate";
    private string statusMessage = "";
    public bool EditMode { get; set; } = false;
    private bool hexMode = false;
    public bool HexMode
        {
        get
            {
            return this.hexMode;
            }
        set
            {
            this.hexMode = value;
            if (this.hexMode)
                {
                Puzzle = new Puzzle(4);
                }
            else
                {
                OnClickLoadPuzzle(); // For now LoadPuzzle() only loads 3x3 block size
                }
            StateHasChanged();
            }
        }

    private void OnClickClearPuzzle()
        {
        Puzzle.Clear();
        }

    private void OnClickLoadPuzzle()
        {
        LoadPuzzle(this.puzzleNumber, this.puzzleDifficulty);
        }

    private void LoadPuzzle(int newPuzzleNumber, string newPuzzleDifficulty)
        {
        Puzzle newPuzzle = Puzzle.LoadPuzzle(newPuzzleNumber - 1, newPuzzleDifficulty);
        if (newPuzzle != null)
            {
            this.hexMode = false;  // Load puzzle only loads 3x3 puzzles for now.
            this.Puzzle = newPuzzle;
            this.puzzleNumber = newPuzzleNumber;
            this.puzzleDifficulty = newPuzzleDifficulty;
            this.statusMessage = "";
            StateHasChanged();
            }
        }

    private void OnClickLoadNextPuzzle()
        {
        LoadPuzzle(this.puzzleNumber + 1, this.puzzleDifficulty);
        }

    private void OnClickLoadPrevPuzzle()
        {
        LoadPuzzle(this.puzzleNumber - 1, this.puzzleDifficulty);
        }

    private void ReportSolutionProgress(object sender, Puzzle.SolutionProgressReport progessReport)
        {
        //Puzzle.SetValue(progessReport.Row, progessReport.Column, progessReport.Value);
        //StateHasChanged();
        }

    private async Task OnClickSolvePuzzle()
        {
        Progress<Puzzle.SolutionProgressReport> progress = new Progress<Puzzle.SolutionProgressReport>();
        progress.ProgressChanged += ReportSolutionProgress;
        this.statusMessage = "Solving...";
        int solutions = await Puzzle.Solve(10, progress, true);

        if (solutions > 0)
            {
            this.statusMessage = $"Found {solutions} solutions.";
            Puzzle solution = Puzzle.Solutions[0];
            for (int row=0; row < Puzzle.Rows; row++)
                {
                for (int column = 0; column < Puzzle.Columns; column++)
                    {
                    Puzzle.Cells[row, column].Value = solution.Cells[row, column].Value;
                    }
                }
            StateHasChanged();
            }
        else
            {
            this.statusMessage = "No soltuions.";
            }
        }

    private void SetFocus(int row, int column)
        {
        SudokuCell sudokuCell = Puzzle.Cells[row, column].View as SudokuCell;

        if (sudokuCell != null)
            {
            sudokuCell.Focus();
            }
        }

    private const bool skipReadOnly = false;

    public void NavigateUp(SudokuCell sudokuCell)
        {
        Puzzle.Cell fromCell = sudokuCell.Cell;
        int row = fromCell.Row;
        int column = fromCell.Column;

        int rowsChecked = 0;
        do
            {
            rowsChecked++;
            if (rowsChecked > Puzzle.Rows)
                return;

            row--;
            // wrap to bottom
            if (row < 0)
                {
                row = Puzzle.Rows - 1;
                }

            } while (skipReadOnly && Puzzle.Cells[row, column].ReadOnly);

        SetFocus(row, column);
        }

    public void NavigateDown(SudokuCell sudokuCell)
        {
        Puzzle.Cell fromCell = sudokuCell.Cell;
        int row = fromCell.Row;
        int column = fromCell.Column;

        int rowsChecked = 0;
        do
            {
            rowsChecked++;
            if (rowsChecked > Puzzle.Rows)
                return;

            row++;
            // wrap to top
            if (row >= Puzzle.Rows)
                {
                row = 0;
                }

            } while (skipReadOnly && Puzzle.Cells[row, column].ReadOnly);

        SetFocus(row, column);
        }

    public void NavigateLeft(SudokuCell sudokuCell)
        {
        Puzzle.Cell fromCell = sudokuCell.Cell;
        int row = fromCell.Row;
        int column = fromCell.Column;

        int columnsChecked = 0;
        do
            {
            columnsChecked++;
            if (columnsChecked > Puzzle.Columns)
                return;

            column--;
            // wrap to right
            if (column < 0)
                {
                column = Puzzle.Columns - 1;
                }

            } while (skipReadOnly && Puzzle.Cells[row, column].ReadOnly);

        SetFocus(row, column);
        }

    public void NavigateRight(SudokuCell sudokuCell)
        {
        Puzzle.Cell fromCell = sudokuCell.Cell;
        int row = fromCell.Row;
        int column = fromCell.Column;

        int columnsChecked = 0;
        do
            {
            columnsChecked++;
            if (columnsChecked > Puzzle.Columns)
                return;

            column++;
            // wrap to left
            if (column >= Puzzle.Columns)
                {
                column = 0;
                }

            } while (skipReadOnly && Puzzle.Cells[row, column].ReadOnly);

        SetFocus(row, column);
        }
    }
