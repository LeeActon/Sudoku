@using Sudoku;
@using BlazingSudoku.Client.Components;

<div class="sudoku-board">
    <span>
        <select @bind="puzzleDifficulty">
            <option value="Simple">Simple</option>
            <option value="Easy">Easy</option>
            <option value="Intermediate">Intermediate</option>
            <option value="Expert">Expert</option>
        </select>
        <input type="text" @bind="puzzleNumber" placeholder="1-100"/>
        <button @onclick="OnClickLoadPuzzle">Load</button>
        <button @onclick="OnClickSolvePuzzle">Solve</button>
    </span>
    <CascadingValue Value="this">
        @for (int row = 0; row < Puzzle.rows; row++)
            {
            if ((row % Puzzle.rowsInBlock) == 0)
                {
                <div class="sudoku-row-gap"/>
                }
            <div class="sudoku-row">
                @for (int column = 0; column < Puzzle.columns; column++)
                    {
                    if ((column % Puzzle.columnsInBlock) == 0)
                        {
                        <div class="sudoku-column-gap"/>
                        }
                    <SudokuCell Cell="@(Puzzle.Cells[row, column])" />
                    }
            </div>
            }
    </CascadingValue>
</div>

@code
    {
    [Parameter] public Puzzle Puzzle { get; set; }
    private int puzzleNumber = 1;
    private string puzzleDifficulty = "Intermediate";

    private void OnClickLoadPuzzle()
        {
        Puzzle newPuzzle = Puzzle.LoadPuzzle(puzzleNumber - 1, puzzleDifficulty);
        if (newPuzzle != null)
            {
            this.Puzzle = newPuzzle;
            StateHasChanged();
            }
        }

    private void ReportSolutionProgress(object sender, Puzzle.SolutionProgressReport progessReport)
        {
        //Puzzle.SetValue(progessReport.Row, progessReport.Column, progessReport.Value);
        //StateHasChanged();
        }

    private async Task OnClickSolvePuzzle()
        {
        Progress<Puzzle.SolutionProgressReport> progress = new Progress<Puzzle.SolutionProgressReport>();
        progress.ProgressChanged += ReportSolutionProgress;
        int solutions = await Puzzle.Solve(1, progress);

        if (solutions > 0)
            {
            Puzzle solution = Puzzle.Solutions[0];
            for (int row=0; row < Puzzle.rows; row++)
                {
                for (int column = 0; column < Puzzle.columns; column++)
                    {
                    Puzzle.SetValue(row, column, solution.GetValue(row, column));
                    }
                }
            StateHasChanged();
            }
        }

    private void SetFocus(int row, int column)
        {
        SudokuCell sudokuCell = Puzzle.Cells[row, column].View as SudokuCell;

        if (sudokuCell != null)
            {
            sudokuCell.Focus();
            }
        }

    private const bool skipReadOnly = false;

    public void NavigateUp(SudokuCell sudokuCell)
        {
        Puzzle.Cell fromCell = sudokuCell.Cell;
        int row = fromCell.Row;
        int column = fromCell.Column;

        int rowsChecked = 0;
        do
            {
            rowsChecked++;
            if (rowsChecked > Puzzle.rows)
                return;

            row--;
            // wrap to bottom
            if (row < 0)
                {
                row = Puzzle.rows - 1;
                }

            } while (skipReadOnly && Puzzle.Cells[row, column].ReadOnly);

        SetFocus(row, column);
        }

    public void NavigateDown(SudokuCell sudokuCell)
        {
        Puzzle.Cell fromCell = sudokuCell.Cell;
        int row = fromCell.Row;
        int column = fromCell.Column;

        int rowsChecked = 0;
        do
            {
            rowsChecked++;
            if (rowsChecked > Puzzle.rows)
                return;

            row++;
            // wrap to top
            if (row >= Puzzle.rows)
                {
                row = 0;
                }

            } while (skipReadOnly && Puzzle.Cells[row, column].ReadOnly);

        SetFocus(row, column);
        }

    public void NavigateLeft(SudokuCell sudokuCell)
        {
        Puzzle.Cell fromCell = sudokuCell.Cell;
        int row = fromCell.Row;
        int column = fromCell.Column;

        int columnsChecked = 0;
        do
            {
            columnsChecked++;
            if (columnsChecked > Puzzle.columns)
                return;

            column--;
            // wrap to right
            if (column < 0)
                {
                column = Puzzle.columns - 1;
                }

            } while (skipReadOnly && Puzzle.Cells[row, column].ReadOnly);

        SetFocus(row, column);
        }

    public void NavigateRight(SudokuCell sudokuCell)
        {
        Puzzle.Cell fromCell = sudokuCell.Cell;
        int row = fromCell.Row;
        int column = fromCell.Column;

        int columnsChecked = 0;
        do
            {
            columnsChecked++;
            if (columnsChecked > Puzzle.columns)
                return;

            column++;
            // wrap to left
            if (column >= Puzzle.columns)
                {
                column = 0;
                }

            } while (skipReadOnly && Puzzle.Cells[row, column].ReadOnly);

        SetFocus(row, column);
        }
    }
