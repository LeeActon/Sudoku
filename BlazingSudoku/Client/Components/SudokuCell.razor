@using Sudoku;
@inject IJSRuntime JSRuntime;

<div @ref="div" id="@ID" class="@CellClass" tabindex="@(TabIndex)" @onkeypress="OnKeyPress" @onkeydown="OnKeyDown">
    @DisplayString
</div>

@code {
    private Puzzle.Cell cell;
    [Parameter] public Puzzle.Cell Cell
        {
        get { return this.cell; }
        set
            {
            this.cell = value;
            if (this.cell != null)
                {
                this.cell.View = this;
                }
            }
        }
    [Parameter] public string ColorClass { get; set; }
    [CascadingParameter] public SudokuBoard SudokuBoard { get; set; }

    private ElementReference div;

    private string CellClass
        {
        get
            {
            return String.Format("sudoku-cell-border-{0}-{1} {2} {3} sudoku-cell ",
                Cell.Row % Puzzle.rowsInBlock,
                Cell.Column % Puzzle.columnsInBlock,
                (Cell.ConflictingCells?.Count > 0) ? "sudoku-cell-conflict" : "",
                Cell.ReadOnly ? "sudoku-cell-readonly" : ""
                );
            }
        }

    private MarkupString DisplayString
        {
        get
            {
            if (Cell.Value == 0)
                return (MarkupString) "&nbsp;";

            return (MarkupString) String.Format("{0}", Cell.Value);
            }
        }

    private int TabIndex
        {
        get
            {
            if (Cell.ReadOnly)
                return -1;

            return 100 + Cell.Row * Puzzle.columns + Cell.Column;
            }
        }

    private void OnKeyDown(KeyboardEventArgs args)
        {
        switch (args.Code)
            {
            case "ArrowUp":
                SudokuBoard.NavigateUp(this);
                break;

            case "ArrowDown":
                SudokuBoard.NavigateDown(this);
                break;

            case "ArrowLeft":
                SudokuBoard.NavigateLeft(this);
                break;

            case "ArrowRight":
                SudokuBoard.NavigateRight(this);
                break;

            case "Space":
            case "Delete":
            case "Backspace":
                UpdateValue(0);
                break;
            }
        }

    private void OnKeyPress(KeyboardEventArgs args)
        {
        switch (args.Key)
            {
            case "1":
                UpdateValue(1);
                break;
            case "2":
                UpdateValue(2);
                break;
            case "3":
                UpdateValue(3);
                break;
            case "4":
                UpdateValue(4);
                break;
            case "5":
                UpdateValue(5);
                break;
            case "6":
                UpdateValue(6);
                break;
            case "7":
                UpdateValue(7);
                break;
            case "8":
                UpdateValue(8);
                break;
            case "9":
                UpdateValue(9);
                break;
            }

        }

    private void UpdateValue(byte newValue)
        {
        if (Cell.Value != newValue)
            {
            List<SudokuCell> sudokuCellsToUpdate = new List<SudokuCell>();

            if (Cell.ConflictingCells != null)
                {
                foreach (Puzzle.Cell conflictingCell in Cell.ConflictingCells)
                    {
                    SudokuCell sudokuCell = conflictingCell.View as SudokuCell;
                    if (sudokuCell != null)
                        {
                        sudokuCellsToUpdate.Add(sudokuCell);
                        }
                    }
                }

            Cell.Value = newValue;

            if (Cell.ConflictingCells != null)
                {
                foreach (Puzzle.Cell conflictingCell in Cell.ConflictingCells)
                    {
                    SudokuCell sudokuCell = conflictingCell.View as SudokuCell;
                    if (sudokuCell != null)
                        {
                        sudokuCellsToUpdate.Add(sudokuCell);
                        }
                    }
                }
            foreach (SudokuCell sudokuCell in sudokuCellsToUpdate)
                {
                sudokuCell.StateHasChanged();
                }

            this.StateHasChanged();
            }
        }

    private string ID { get { return $"cell-{Cell.Row}-{Cell.Column}"; } }
    public void Focus()
        {
        // Dang! No easy way to set the focus.
        // There's JavaScript code in index.html that can be called to set the focus to an element by id.
        JSRuntime.InvokeAsync<int>("setFocus", (object) ID);
        }
    }
